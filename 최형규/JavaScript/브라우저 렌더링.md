# 브라우저 렌더링



## 목차

#### 브라우저

#### 브라우저 기본 구조

#### 렌더링 엔진

#### 브라우저의 오류 처리

#### 브라우저 렌더링 동작 과정

- **Parsing**
- **Style**
- **Layout / Reflow**
- **Painting**
- **Composite**



## 브라우저

- (MDN) 브라우저에 대해 웹에서 페이지를 찾아서 보여주고, 사용자가 하이퍼링크를 통해 다른 페이지로 이동할 수 있도록 하는 프로그램 

- 브라우저는 **유저가 선택한 자원**을 서버로 부터 받아와서 렌더링 과정을 통해 유저에게 보여주게 됨
  - 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해짐



## 브라우저의 기본 구조

1. **사용자 인터페이스**
   - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
2. **브라우저 엔진**
   - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
3. **렌더링 엔진**
   - 요청받은 내용을 브라우저 화면에 표시
   - ex) HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시
4. **통신**
   - HTTP 요청과 같은 네트워크 호출에 사용됨
   - 플랫폼 독립적인 인터페이스이고, 각 플랫폼 하부에서 실행됨
5. **UI 백엔드**
   - 콤보 박스와 창 같은 기본적인 장치를 그림
   - 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용
6. **자바스크립트 해석기**
   - 자바스크립트 코드를 해석하고 실행
7. **자료 저장소**
   - 자료를 저장하는 계층
   - 쿠키 등 모든 종류의 자원을 하드 디스크에 저장할 필요가 있음
   - HTML5 명세에는 브라우저가 지원하는 '[웹 데이터 베이스](https://web.dev/)'가 정의되어 있음

![브라우저 기본 구조](../images/3.png)



#### 렌더링 엔진

- **게코(Gecko) 엔진** : 모질라 제작, 파이어폭스 사용

  ![Gecko](../images/5.png)

- **웹킷(Webkit) 엔진** : 오픈소스 엔진, 사파리, 크롬 사용

  ![Webkit](../images/4.png)

- 게코와 웹킷은 용어 차이만 존재, 기본 동작 과정은 동일

  |         게코 엔진         |       웹킷 엔진        |
  | :-----------------------: | :--------------------: |
  |   형상 트리(frame tree)   | 렌더 트리(render tree) |
  |      리플로(reflow)       |      배치(layout)      |
  | 콘텐츠 싱크(content sink) | 어태치먼트(attachment) |

- 렌더링 엔진은 모든HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작

  => 더 나은 사용자 경험 제공



## 브라우저의 오류 처리

- HTML 페이지에서 "유효하지 않은 구문"이라는 오류는 없음
- 이유
  - 브라우저가 모든 오류 구문을 교정하기 때문



## 브라우저 렌더링 동작 과정

![render path](../images/6.png)

#### 기본적인 동작 과정

1. **(Parsing)** HTML 파일과 CSS 파일을 파싱해서 각각 Tree를 만든다.
2. **(Style)** 두 Tree를 결합하여 Rendering Tree를 만든다.
3. **(Layout)** Rendering Tree에서 각 노드의 위치와 크기를 계산한다.
4. **(Paint)** 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다.
5. **(Composite)** 레이러를 합성하여 실제 화면에 나타낸다.



#### Parsing

- HTML 파일을 해석하여 **DOM(Document Object Model) Tree**를 구성하는 단계
- 파싱 중 HTML에 CSS가 포함되어 있다면 **CSSOM(CSS Object Model) Tree** 구성 작업도 함께 진행

![DOM/CSSOM](../images/1.png)



#### Style

- 생성된 DOM Tree와 CSSOM Tree를 매칭시켜 **Render Tree**를 구성
  - Render Tree : 실제로 화면에 그려질 Tree
  - ex) CSS - `visibility: hidden` 속성을 주면 요소가 공간을 차지하지만, 보이지 않기 때문에 Render Tree에는 포함이 되지만, CSS - `display: none` 의 경우 Render Tree에서 제외됨

![Render Tree](../images/2.png)



#### Layout

- Render Tree를 화면에 어떻게 배치해야 할 것인지 노트의 정확한 위치와 크기를 계산
- 루트부터 노드를 순회하면서 노드의 정확한 크기와 위치를 계산하고 Render Tree에 반영
  - ex) 크기 값을 %로 지정했다면, Layout 단계에서 % 값을 계산해 픽셀 단위로 변환



#### Paint

- Layout 단계에서 계산된 값을 이용해 Render Tree의 각 노드를 화면상의 실제 픽셀로 변환
- 픽셀로 변환된 결과는 하나의 레이어가 아니라 여러 개의 레이어로 관리됨
- 스타일이 복잡할수록 Paint 시간도 증가
  - ex) 단색 배경일 경우, 시간과 작업이 적게 필요



#### Composite

- Paint 단계에서 생성된 레이어를 합성하여 실제 화면에 나타냄



#### 출처

- https://tecoble.techcourse.co.kr/post/2021-10-24-browser-rendering/
- https://d2.naver.com/helloworld/59361 => 굳